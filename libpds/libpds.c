
/* Copyright 2013 Kjetil S. Matheussen

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. */


#include <dlfcn.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <stdbool.h>
#include <dirent.h>
#include <sys/time.h>
#include <errno.h>

#include "libpds.h"

#include "libpd_so.c"
#include "libpds_autogenerated.c"


static char error_string[1024] = {0};

static char *get_unique_temp_string(char *ret, char *postfix){
  struct timeval my_timeval;
  gettimeofday(&my_timeval, NULL);

  sprintf(ret,"/tmp/libpd_%llu_%llu_%d_XXXXXX%s", (unsigned long long)my_timeval.tv_sec, (unsigned long long)my_timeval.tv_usec, rand(), postfix);
  return ret;
}

static bool write_libpd_so_to_tempfile(char *template){
  int fd = mkostemps(template, 3, S_IRUSR | S_IXUSR);
  int num_bytes = write(fd, libs_libpd_so, sizeof(libs_libpd_so));

  if (num_bytes!=sizeof(libs_libpd_so)){
    sprintf(error_string,"Couldn't create file %s.",template);
    return false;
  }

  close(fd);
  return true;
}

pd_t *libpds_create(bool use_gui, const char *libdir){
  //print_all("/home/kjetil/temp/pd-extended/externals/build/lib/pd-extended/extra/vanilla/");
  char temp[1024];

  pd_t *pd = calloc(1, sizeof(pd_t));

  char unlibered_filename[1024];
  sprintf(unlibered_filename, "%s", get_unique_temp_string(temp, ".so"));
  if (write_libpd_so_to_tempfile(unlibered_filename)==false)
    return NULL;

  pd->handle = dlopen(unlibered_filename, RTLD_NOW | RTLD_LOCAL);
  if (!pd->handle) {
    sprintf(error_string, "Unable to create libpds instance. Error message: \"%s\" Filename: %s", dlerror(), unlibered_filename);
    fprintf(stderr, "%s\n", error_string);
    return NULL;
  }

  load_symbols(pd);

  if (pd->libpd_init(use_gui, libdir)==false) {
    dlclose(pd->handle);
    free(pd);
    sprintf(error_string, "libpd_init returned false. (Likely that the GUI couldn't be started).");
    return NULL;
  }

  pd->libfilename = strdup(unlibered_filename);
  return pd;
}

// Not threadsafe. If having several errors at once, the function could return strange result.
char *libpds_strerror(void) {
  return error_string;
}

void libpds_delete(pd_t *pd) {
  pd->libpd_cleanup();
  dlclose(pd->handle);
  unlink(pd->libfilename);
  free(pd->libfilename);
  free(pd);
}

