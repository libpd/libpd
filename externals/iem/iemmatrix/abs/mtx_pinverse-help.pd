#N canvas 366 49 705 646 10;
#X text 347 472 updated for;
#X obj 435 472 iemmatrix 0.2;
#X obj 484 498 matrix;
#X text 354 497 see also help for;
#X text 243 142 singular;
#X text 245 107 regular;
#X text 246 158 regular;
#X text 247 168 but badly conditioned;
#X text 154 533 A*inv(A)=inv(A)*A=I;
#X text 248 221 pseudoinverse: P1=inv(A'*A)*A';
#X text 247 269 pseudoinverse: P2=A'*inv(A*A');
#X text 245 553 P1*A=I;
#X text 245 573 A*P2=I;
#X obj 92 199 mtx 3;
#X msg 112 164 1 2 3 2 4 4 3 4 5;
#X msg 92 108 1 2 4 2 3 4 3 4 5;
#X obj 92 472 mtx_print inverse;
#X obj 92 300 t a a;
#X obj 134 300 mtx_print original;
#X obj 153 219 mtx_rand 4 3;
#X msg 153 198 bang;
#X msg 153 248 bang;
#X obj 153 269 mtx_rand 3 4;
#X obj 182 348 bng 15 250 50 0 empty empty empty 0 -6 0 8 -262144 -1
-1;
#X text 199 359 instability detected!;
#X obj 92 348 mtx_pinverse;
#X text 45 16 mtx_pinverse:: get the inverse of a matrix (with pivoting)
;
#X text 44 49 mtx_pinverse calculates the inverse of a square-matrix.
For inverting rectangle matrices \, use [mtx_inverse] or [mtx_pseudoinverse]
;
#X msg 103 140 1 2 3 2 3 4 0 0 0;
#X text 194 385 due to pivoting \, [mtx_pinverse] will handle badly
conditioned matrices better than [mtx_inverse] \, however it will also
detect less (real) instabilities than [mtx_inverse];
#X obj 485 524 mtx_inverse;
#X obj 485 548 mtx_pseudoinverse;
#X connect 13 0 17 0;
#X connect 14 0 13 0;
#X connect 15 0 13 0;
#X connect 17 0 25 0;
#X connect 17 1 18 0;
#X connect 19 0 17 0;
#X connect 20 0 19 0;
#X connect 21 0 22 0;
#X connect 22 0 17 0;
#X connect 25 0 16 0;
#X connect 25 1 23 0;
#X connect 28 0 13 0;
