#N canvas 0 0 838 657 10;
#X declare -path ..;
#N canvas 713 200 450 300 delay~ 0;
#X obj 74 145 delread~ \$0-line 10;
#X obj 124 86 delwrite~ \$0-line 2000;
#X obj 125 64 r~ input;
#X obj 74 170 throw~ in_delayed;
#X obj 74 26 inlet;
#X connect 0 0 3 0;
#X connect 2 0 1 0;
#X connect 4 0 0 0;
#X restore 292 335 pd delay~;
#N canvas 221 213 610 340 channel~ 0;
#X obj 218 294 s~ channel;
#X obj 40 28 r~ input;
#X obj 56 78 expr if($f1==1 \, 1 \, 0);
#X obj 56 58 r mode;
#X obj 56 98 tgl 15 0 empty empty empty 0 -6 0 8 -262144 -1 -1 0 1
;
#X obj 40 116 *~;
#X obj 234 59 r mode;
#X obj 234 99 tgl 15 0 empty empty empty 0 -6 0 8 -262144 -1 -1 0 1
;
#X obj 218 117 *~;
#X obj 218 29 r~ eq;
#X obj 234 79 expr if($f1==2 \, 1 \, 0);
#N canvas 582 508 581 396 a_room~ 0;
#X obj 29 30 inlet~;
#X obj 27 358 outlet~;
#X obj 367 219 bp~ 500 10;
#X obj 29 144 dac~;
#X obj 27 273 adc~;
#X text 27 163 speaker;
#X text 25 211 a room;
#X text 25 254 micro;
#X obj 46 53 s~ vol_out;
#X obj 28 89 *~;
#X obj 57 89 r~ out_vol;
#X obj 27 300 *~;
#X obj 56 300 r~ in_vol;
#X obj 398 170 tgl 15 0 empty empty empty 0 -6 0 8 -262144 -1 -1 1
1;
#X obj 366 185 *~;
#X obj 398 130 r channel;
#X obj 368 291 *~;
#X text 365 104 dummy filter + latency;
#X obj 174 101 tgl 15 0 empty empty empty 0 -6 0 8 -262144 -1 -1 0
1;
#X obj 29 116 *~;
#X obj 174 61 r channel;
#X text 169 40 real room;
#X obj 27 330 *~;
#X obj 174 81 expr if($f1==1 \, 1 \, 0);
#X obj 398 150 expr if($f1==0 \, 1 \, 0);
#X obj 369 266 delread~ \$0-line2 10;
#X obj 368 242 delwrite~ \$0-line2 11;
#X connect 0 0 8 0;
#X connect 0 0 9 0;
#X connect 0 0 14 0;
#X connect 2 0 26 0;
#X connect 4 0 11 0;
#X connect 9 0 19 0;
#X connect 10 0 9 1;
#X connect 11 0 22 0;
#X connect 12 0 11 1;
#X connect 13 0 14 1;
#X connect 13 0 16 1;
#X connect 14 0 2 0;
#X connect 15 0 24 0;
#X connect 16 0 1 0;
#X connect 18 0 19 1;
#X connect 18 0 22 1;
#X connect 19 0 3 0;
#X connect 20 0 23 0;
#X connect 22 0 1 0;
#X connect 23 0 18 0;
#X connect 24 0 13 0;
#X connect 25 0 16 0;
#X restore 218 207 pd a_room~;
#X obj 385 31 catch~ channel_in;
#X obj 402 59 r mode;
#X obj 402 99 tgl 15 0 empty empty empty 0 -6 0 8 -262144 -1 -1 0 1
;
#X obj 386 117 *~;
#X obj 402 79 expr if($f1==0 \, 1 \, 0);
#X obj 231 239 throw~ channel_out;
#X connect 1 0 5 0;
#X connect 2 0 4 0;
#X connect 3 0 2 0;
#X connect 4 0 5 1;
#X connect 5 0 11 0;
#X connect 6 0 10 0;
#X connect 7 0 8 1;
#X connect 8 0 11 0;
#X connect 9 0 8 0;
#X connect 10 0 7 0;
#X connect 11 0 0 0;
#X connect 11 0 17 0;
#X connect 12 0 15 0;
#X connect 13 0 16 0;
#X connect 14 0 15 1;
#X connect 15 0 11 0;
#X connect 16 0 14 0;
#X restore 78 354 pd channel~;
#N canvas 775 0 479 464 PROBLEM_DESCRIPTION 0;
#X text 166 24 INVERSE MODELLING;
#X text 34 66 Now the signal source is split up into an unknown channel
and the desired signal is delayed added into the adaption process.
;
#X text 32 115 The goal is to adapt the channel \, so that the overal
system has a flat frequency response:;
#X text 32 177 So the overal system is a delayed version of the input
signal.;
#X text 47 312 1 select a channel (dummy system or a real room - so
you will need a loudspeaker and a microphone);
#X text 142 154 H_ch(z) * H_eq(z) = z^-M;
#X text 45 381 3 train the system \, to get H_eq(z) (use speech- or
music samples to train the real room);
#X text 46 414 4 use the euqlized system (in case of a real room you
should have a nearly flat frequency response in that room);
#X text 30 290 Usage of the patch:;
#X text 47 347 2 measure the latency of your system (for real room:
don't forget to turn on the volumes for micro and speaker);
#X text 60 239 a) dummy system: a simple bandpass filter with a delay
;
#X text 62 253 b) real room: loudspeaker - a room - micro;
#X text 29 221 You can select between two different channels:;
#X restore 28 83 pd PROBLEM_DESCRIPTION;
#N canvas 844 224 455 275 OBSERVATIONS 0;
#X text 152 22 OBSERVATIONS;
#X text 32 95 The magnitude of the frequency response can be equalized.
;
#X text 14 75 dummy system:;
#X text 16 128 a real room:;
#X text 33 148 The magnitude of the frequency can only be equalized
if you have an input signal with high energy.;
#X text 31 181 The adaptation has problems with noise as input signal
\, because noise is totally uncorrelated \, so you to measure the latency
very precise.;
#X text 30 227 Because of that it is better to use more correlated
signals such as music or speech samples.;
#X restore 28 107 pd OBSERVATIONS;
#X text 27 62 ReadMe:;
#X obj 491 42 spectrum~;
#X obj 742 25 r scopes_on;
#X obj 652 25 r tlp;
#N canvas 752 62 617 210 init 0;
#X msg 43 99 2;
#X obj 256 43 loadbang;
#X obj 43 122 s init_tlp;
#X obj 213 120 s mur;
#X msg 212 96 0.01;
#X msg 515 103 \; pd dsp \$1;
#X obj 515 78 r audio_io;
#X obj 145 122 s moder;
#X msg 145 100 3;
#X obj 268 119 s channelr;
#X msg 268 97 0;
#X obj 352 119 s insigr;
#X msg 353 98 0;
#X connect 0 0 2 0;
#X connect 1 0 0 0;
#X connect 1 0 4 0;
#X connect 1 0 8 0;
#X connect 1 0 10 0;
#X connect 1 0 12 0;
#X connect 4 0 3 0;
#X connect 6 0 5 0;
#X connect 8 0 7 0;
#X connect 10 0 9 0;
#X connect 12 0 11 0;
#X restore 770 449 pd init;
#X obj 491 254 spectrum~;
#X obj 742 237 r scopes_on;
#X obj 652 237 r tlp;
#X text 496 497 VISUALIZATIONS:;
#X obj 298 577 tgl 20 0 audio_io empty empty 0 -6 0 8 -262144 -1 -1
0 1;
#X text 323 579 <- Audio IO;
#X obj 42 579 tgl 20 0 scopes_on empty empty 0 -6 0 8 -262144 -1 -1
0 1;
#X text 69 581 <- Visualization IO;
#X floatatom 42 612 5 0 100 0 - init_tlp tlp;
#X text 83 612 <- temporal lowpass for spectrum view (0...100);
#X floatatom 367 533 6 0 0 0 - mur mu;
#X text 229 532 learning rate (mu):;
#X text 26 26 ADAPTIVE EQUALIZATION: INVERSE MODELING;
#X obj 491 25 r~ eq;
#X obj 491 237 r~ channel;
#N canvas 869 353 450 300 input_signal~ 0;
#X obj 59 74 noise~;
#X obj 58 244 s~ input;
#X obj 333 120 inlet;
#N canvas 0 0 450 300 sample~ 0;
#X obj 15 26 inlet;
#X obj 44 262 outlet~;
#X obj 45 202 readsf~;
#X msg 45 144 open /win/Georg/pd/holzilib/samples/Mandarin.wav;
#X obj 130 80 openpanel;
#X obj 130 57 bng 15 250 50 0 empty empty empty 0 -6 0 8 -262144 -1
-1;
#X msg 130 105 set open \$1;
#X obj 89 224 t b b;
#X msg 73 170 1;
#X obj 15 83 t f b;
#X obj 183 41 inlet;
#X connect 0 0 9 0;
#X connect 2 0 1 0;
#X connect 2 1 7 0;
#X connect 3 0 2 0;
#X connect 4 0 6 0;
#X connect 5 0 4 0;
#X connect 6 0 3 0;
#X connect 7 0 8 0;
#X connect 7 1 3 0;
#X connect 8 0 2 0;
#X connect 9 0 2 0;
#X connect 9 1 3 0;
#X connect 10 0 4 0;
#X restore 268 150 pd sample~;
#X obj 268 74 r insig;
#X obj 268 98 expr if($f1==1 \, 1 \, 0);
#X obj 268 122 tgl 15 0 empty empty empty 0 -6 0 8 -262144 -1 -1 0
1;
#X obj 58 138 *~;
#X obj 106 75 r insig;
#X obj 106 123 tgl 15 0 empty empty empty 0 -6 0 8 -262144 -1 -1 0
1;
#X obj 106 99 expr if($f1==0 \, 1 \, 0);
#X connect 0 0 7 0;
#X connect 2 0 3 1;
#X connect 3 0 1 0;
#X connect 4 0 5 0;
#X connect 5 0 6 0;
#X connect 6 0 3 0;
#X connect 7 0 1 0;
#X connect 8 0 10 0;
#X connect 9 0 7 1;
#X connect 10 0 9 0;
#X restore 144 293 pd input_signal~;
#N canvas 573 367 441 300 adaptive_equalizer~ 0;
#X obj 52 248 s~ eq;
#X obj 71 184 r~ channel;
#N canvas 922 527 390 347 nlms3~ 0;
#X obj 37 35 inlet~;
#X obj 268 36 inlet~;
#X text 247 16 desired signal;
#X obj 36 291 outlet~;
#X obj 261 135 loadbang;
#X msg 264 300 clear;
#X obj 262 250 r mu;
#X msg 262 272 mu \$1;
#X obj 150 34 inlet~;
#X text 36 313 outsig1;
#X text 38 14 insig1;
#X text 149 15 insig2;
#X msg 274 201 init_unity;
#X obj 261 156 t b b;
#X msg 59 96 print;
#X obj 263 86 block~ 128;
#X msg 261 178 adaptation 0;
#X obj 341 38 inlet;
#X obj 37 156 nlms3~ 10 0.01;
#X connect 0 0 18 0;
#X connect 1 0 18 2;
#X connect 4 0 13 0;
#X connect 5 0 18 0;
#X connect 6 0 7 0;
#X connect 7 0 18 0;
#X connect 8 0 18 1;
#X connect 12 0 18 0;
#X connect 13 0 16 0;
#X connect 13 1 12 0;
#X connect 14 0 18 0;
#X connect 16 0 18 0;
#X connect 17 0 18 0;
#X connect 18 0 3 0;
#X restore 51 220 pd nlms3~;
#X obj 66 94 expr if($f1==1 \, 1 \, 0);
#X obj 66 74 r mode;
#X obj 66 114 tgl 15 0 empty empty empty 0 -6 0 8 -262144 -1 -1 0 1
;
#X obj 50 132 *~;
#X obj 282 205 expr if($f1==1 \, 1 \, 0);
#X obj 282 185 r mode;
#X obj 282 225 tgl 15 0 empty empty empty 0 -6 0 8 -262144 -1 -1 0
1;
#X msg 282 244 adaptation \$1;
#X obj 251 75 r mode;
#X obj 251 115 tgl 15 0 empty empty empty 0 -6 0 8 -262144 -1 -1 0
1;
#X obj 235 133 *~;
#X obj 251 95 expr if($f1==2 \, 1 \, 0);
#X obj 50 44 r~ channel;
#X obj 235 45 r~ input;
#X obj 147 184 catch~ in_delayed;
#X connect 1 0 2 1;
#X connect 2 0 0 0;
#X connect 3 0 5 0;
#X connect 4 0 3 0;
#X connect 5 0 6 1;
#X connect 6 0 2 0;
#X connect 7 0 9 0;
#X connect 8 0 7 0;
#X connect 9 0 10 0;
#X connect 10 0 2 3;
#X connect 11 0 14 0;
#X connect 12 0 13 1;
#X connect 13 0 2 0;
#X connect 14 0 12 0;
#X connect 15 0 6 0;
#X connect 16 0 13 0;
#X connect 17 0 2 2;
#X restore 201 356 pd adaptive_equalizer~;
#X text 460 130 (1);
#X text 460 338 (2);
#X obj 46 161 vradio 20 1 0 4 mode moder empty 0 -6 0 8 -262144 -1
-1 3;
#X text 68 163 calculate latency of the channel;
#X text 68 183 train to get the inverse system;
#X text 69 202 use equalized system;
#X text 41 144 mode:;
#X text 517 520 training mode:;
#X text 86 374 H_chan(z);
#X text 252 376 H_eq(z);
#X text 532 536 (1) H_chan(z) * H_eq(z);
#X text 532 551 (2) H_chan(z) (= channel);
#X text 516 572 using mode:;
#X text 529 589 (1) H_eq(z) (= 1/H_chan(z) = equalizer);
#X text 529 604 (2) H_chan(z) * H_eq(z);
#N canvas 815 256 526 453 latency_measurement 0;
#X obj 38 118 metro 500;
#X msg 38 163 0.5;
#X obj 72 142 del 3;
#X msg 72 162 0;
#X obj 289 231 timer;
#X floatatom 319 260 9 0 0 0 - - -;
#X obj 319 203 threshold~ 0.1 5 0.05 5;
#X obj 38 186 vline~;
#X obj 133 204 threshold~ 0.1 5 0.05 5;
#X obj 38 55 r mode;
#X obj 38 95 tgl 15 0 empty empty empty 0 -6 0 8 -262144 -1 -1 0 1
;
#X obj 38 75 expr if($f1==0 \, 1 \, 0);
#X obj 38 277 throw~ channel_in;
#X obj 318 179 catch~ channel_out;
#X text 339 275 latency in ms;
#X obj 289 376 s delay;
#X text 157 25 measure latency of the channel;
#X obj 289 295 spigot;
#X obj 289 349 max 0;
#X obj 289 322 - 1.6;
#X connect 0 0 1 0;
#X connect 0 0 2 0;
#X connect 1 0 7 0;
#X connect 2 0 3 0;
#X connect 3 0 7 0;
#X connect 4 0 5 0;
#X connect 4 0 17 0;
#X connect 6 0 4 1;
#X connect 7 0 8 0;
#X connect 7 0 12 0;
#X connect 8 0 4 0;
#X connect 9 0 11 0;
#X connect 10 0 0 0;
#X connect 10 0 17 1;
#X connect 11 0 10 0;
#X connect 13 0 6 0;
#X connect 17 0 19 0;
#X connect 18 0 15 0;
#X connect 19 0 18 0;
#X restore 611 449 pd latency_measurement;
#X floatatom 292 317 5 0 2000 1 ms delay -;
#X obj 44 476 hsl 128 15 0 127 0 0 empty empty empty -2 -6 0 8 -262144
-1 -1 0 1;
#N canvas 490 130 319 220 audio_out 0;
#X obj 37 161 env~;
#X obj 36 68 r~ vol_out;
#X obj 37 136 *~;
#X obj 119 80 dbtorms;
#X obj 119 120 line~;
#X msg 119 100 \$1 50;
#X obj 119 58 inlet;
#X obj 37 184 outlet;
#X obj 119 147 s~ out_vol;
#X connect 0 0 7 0;
#X connect 1 0 2 0;
#X connect 2 0 0 0;
#X connect 3 0 5 0;
#X connect 4 0 2 1;
#X connect 4 0 8 0;
#X connect 5 0 4 0;
#X connect 6 0 3 0;
#X restore 41 456 pd audio_out;
#X floatatom 41 438 5 0 200 1 dB - -;
#X obj 184 476 hsl 128 15 0 127 0 0 empty empty empty -2 -6 0 8 -262144
-1 -1 0 1;
#X floatatom 181 438 5 0 200 1 dB - -;
#N canvas 490 130 319 220 audio_in 0;
#X obj 37 161 env~;
#X obj 37 136 *~;
#X obj 119 80 dbtorms;
#X obj 119 120 line~;
#X msg 119 100 \$1 50;
#X obj 119 58 inlet;
#X obj 37 184 outlet;
#X obj 36 68 adc~;
#X obj 119 148 s~ in_vol;
#X connect 0 0 6 0;
#X connect 1 0 0 0;
#X connect 2 0 4 0;
#X connect 3 0 1 1;
#X connect 3 0 8 0;
#X connect 4 0 3 0;
#X connect 5 0 2 0;
#X connect 7 0 1 0;
#X restore 181 456 pd audio_in;
#X floatatom 181 491 5 0 200 1 dB - -;
#X floatatom 41 491 5 0 200 1 dB - -;
#X obj 78 322 vradio 15 1 0 2 channel channelr empty 0 -6 0 8 -262144
-1 -1 0;
#X text 96 322 dummy filter;
#X text 96 336 a real room;
#X text 40 416 adjust volumes to measure a room:;
#X text 49 164 1;
#X text 49 184 2;
#X text 49 204 3;
#X obj 144 261 vradio 15 1 0 2 insig insigr empty 0 -6 0 8 -262144
-1 -1 0;
#X text 162 261 noise;
#X text 161 275 sample;
#X obj 243 278 bng 15 250 50 0 empty empty empty 0 -6 0 8 -262144 -1
-1;
#X text 216 262 open sample;
#X connect 6 0 5 2;
#X connect 7 0 5 1;
#X connect 10 0 9 2;
#X connect 11 0 9 1;
#X connect 22 0 5 0;
#X connect 23 0 9 0;
#X connect 42 0 0 0;
#X connect 43 0 50 0;
#X connect 44 0 43 0;
#X connect 45 0 44 0;
#X connect 46 0 49 0;
#X connect 47 0 48 0;
#X connect 48 0 46 0;
#X connect 61 0 24 0;
